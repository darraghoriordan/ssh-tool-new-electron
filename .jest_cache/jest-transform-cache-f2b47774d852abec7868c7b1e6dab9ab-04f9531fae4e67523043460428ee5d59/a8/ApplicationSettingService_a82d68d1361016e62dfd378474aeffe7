fef38df8abf4d1d580c123376305db4a
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ApplicationSettingService = void 0;
const promises_1 = __importDefault(require("fs/promises"));
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const os_1 = __importDefault(require("os"));
const electron_1 = require("electron");
const class_transformer_1 = require("class-transformer");
const ApplicationSettings_1 = require("../models/ApplicationSettings");
const DefaultSettingsMac_1 = require("../models/DefaultSettingsMac");
const DefaultSettingsLinux_1 = require("../models/DefaultSettingsLinux");
const DefaultSettingsWindows_1 = require("../models/DefaultSettingsWindows");
const class_validator_1 = require("class-validator");
class ApplicationSettingService {
    static getSettings() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.loadedSettings === undefined) {
                this.loadedSettings = yield this.loadFile(this.filePath);
            }
            return this.loadedSettings;
        });
    }
    static loadFile(path) {
        return __awaiter(this, void 0, void 0, function* () {
            console.log(`loading settings file path ${ApplicationSettingService.filePath}`);
            // trying to catch the error on promises readFile still throws for some reason
            // so using this instead
            if (!fs_1.default.existsSync(path)) {
                const settingsInstance = this.getDefaultSettings();
                this.saveFile(settingsInstance);
                return settingsInstance;
            }
            const fileUtf8 = yield promises_1.default.readFile(path, { encoding: 'utf-8' });
            const settingsInstance = (0, class_transformer_1.plainToInstance)(ApplicationSettings_1.ApplicationSettings, JSON.parse(fileUtf8));
            return settingsInstance;
        });
    }
    static getDefaultSettings() {
        const defaultSettings = [
            new DefaultSettingsMac_1.DefaultSettingsMac(),
            new DefaultSettingsWindows_1.DefaultSettingsWindows(),
            new DefaultSettingsLinux_1.DefaultSettingsLinux(),
        ];
        const defaultSettingsInstance = defaultSettings.find(x => x.platformMatcher === os_1.default.platform());
        if (defaultSettingsInstance === undefined) {
            throw new Error("Couldn't find application configuration to run on current platform. Only mac, windows and linux supported.");
        }
        return defaultSettingsInstance;
    }
    static saveFile(settings) {
        return __awaiter(this, void 0, void 0, function* () {
            console.log(`saving settings file path ${ApplicationSettingService.filePath}`, settings);
            // would probably want to validate the settings here
            //validateOrReject(settings)
            const validationErrors = yield (0, class_validator_1.validate)((0, class_transformer_1.plainToInstance)(ApplicationSettings_1.ApplicationSettings, settings));
            if (validationErrors && validationErrors.length > 0) {
                const errors = validationErrors.map(v => v.toString());
                throw new Error(`The settings are invalid. ${''.concat(...errors)}`);
            }
            console.log('validation errors', validationErrors);
            yield promises_1.default.writeFile(this.filePath, JSON.stringify((0, class_transformer_1.instanceToPlain)(settings)));
            this.loadedSettings = settings;
        });
    }
    static deleteFile() {
        return __awaiter(this, void 0, void 0, function* () {
            console.log(`deleting settings file path ${ApplicationSettingService.filePath}`);
            yield promises_1.default.rm(this.filePath, { force: true });
            this.loadedSettings = undefined;
        });
    }
}
exports.ApplicationSettingService = ApplicationSettingService;
ApplicationSettingService.filePath = path_1.default.join(electron_1.app.getPath('userData'), 'appSettings.json');
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL2RhcnJhZ2hvcmlvcmRhbi9Eb2N1bWVudHMvcGVyc29uYWwtcHJvamVjdHMvc3NoLXRvb2wtbmV3LWVsZWN0cm9uL3NyYy9lbGVjdHJvbi9hcHBTZXR0aW5ncy9zZXJ2aWNlcy9BcHBsaWNhdGlvblNldHRpbmdTZXJ2aWNlLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFBLDJEQUE2QjtBQUM3Qiw0Q0FBbUI7QUFDbkIsZ0RBQXVCO0FBQ3ZCLDRDQUFtQjtBQUNuQix1Q0FBOEI7QUFDOUIseURBQW9FO0FBQ3BFLHVFQUFtRTtBQUNuRSxxRUFBaUU7QUFDakUseUVBQXFFO0FBQ3JFLDZFQUF5RTtBQUN6RSxxREFBMEM7QUFFMUMsTUFBYSx5QkFBeUI7SUFRcEMsTUFBTSxDQUFPLFdBQVc7O1lBQ3RCLElBQUksSUFBSSxDQUFDLGNBQWMsS0FBSyxTQUFTLEVBQUU7Z0JBQ3JDLElBQUksQ0FBQyxjQUFjLEdBQUcsTUFBTSxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQTthQUN6RDtZQUVELE9BQU8sSUFBSSxDQUFDLGNBQWMsQ0FBQTtRQUM1QixDQUFDO0tBQUE7SUFFRCxNQUFNLENBQU8sUUFBUSxDQUFDLElBQVk7O1lBQ2hDLE9BQU8sQ0FBQyxHQUFHLENBQ1QsOEJBQThCLHlCQUF5QixDQUFDLFFBQVEsRUFBRSxDQUNuRSxDQUFBO1lBQ0QsOEVBQThFO1lBQzlFLHdCQUF3QjtZQUN4QixJQUFJLENBQUMsWUFBRSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsRUFBRTtnQkFDeEIsTUFBTSxnQkFBZ0IsR0FBRyxJQUFJLENBQUMsa0JBQWtCLEVBQUUsQ0FBQTtnQkFDbEQsSUFBSSxDQUFDLFFBQVEsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFBO2dCQUUvQixPQUFPLGdCQUFnQixDQUFBO2FBQ3hCO1lBRUQsTUFBTSxRQUFRLEdBQUcsTUFBTSxrQkFBRyxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUUsRUFBRSxRQUFRLEVBQUUsT0FBTyxFQUFFLENBQUMsQ0FBQTtZQUVoRSxNQUFNLGdCQUFnQixHQUFHLElBQUEsbUNBQWUsRUFDdEMseUNBQW1CLEVBQ25CLElBQUksQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLENBQ3JCLENBQUE7WUFDRCxPQUFPLGdCQUFnQixDQUFBO1FBQ3pCLENBQUM7S0FBQTtJQUVELE1BQU0sQ0FBQyxrQkFBa0I7UUFJdkIsTUFBTSxlQUFlLEdBQUc7WUFDdEIsSUFBSSx1Q0FBa0IsRUFBRTtZQUN4QixJQUFJLCtDQUFzQixFQUFFO1lBQzVCLElBQUksMkNBQW9CLEVBQUU7U0FDM0IsQ0FBQTtRQUVELE1BQU0sdUJBQXVCLEdBQUcsZUFBZSxDQUFDLElBQUksQ0FDbEQsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsZUFBZSxLQUFLLFlBQUUsQ0FBQyxRQUFRLEVBQUUsQ0FDekMsQ0FBQTtRQUNELElBQUksdUJBQXVCLEtBQUssU0FBUyxFQUFFO1lBQ3pDLE1BQU0sSUFBSSxLQUFLLENBQ2IsNEdBQTRHLENBQzdHLENBQUE7U0FDRjtRQUVELE9BQU8sdUJBQXVCLENBQUE7SUFDaEMsQ0FBQztJQUVELE1BQU0sQ0FBTyxRQUFRLENBQUMsUUFBNkI7O1lBQ2pELE9BQU8sQ0FBQyxHQUFHLENBQ1QsNkJBQTZCLHlCQUF5QixDQUFDLFFBQVEsRUFBRSxFQUNqRSxRQUFRLENBQ1QsQ0FBQTtZQUVELG9EQUFvRDtZQUNwRCw0QkFBNEI7WUFDNUIsTUFBTSxnQkFBZ0IsR0FBRyxNQUFNLElBQUEsMEJBQVEsRUFDckMsSUFBQSxtQ0FBZSxFQUFDLHlDQUFtQixFQUFFLFFBQVEsQ0FBQyxDQUMvQyxDQUFBO1lBQ0QsSUFBSSxnQkFBZ0IsSUFBSSxnQkFBZ0IsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFO2dCQUNuRCxNQUFNLE1BQU0sR0FBRyxnQkFBZ0IsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsUUFBUSxFQUFFLENBQUMsQ0FBQTtnQkFDdEQsTUFBTSxJQUFJLEtBQUssQ0FBQyw2QkFBNkIsRUFBRSxDQUFDLE1BQU0sQ0FBQyxHQUFHLE1BQU0sQ0FBQyxFQUFFLENBQUMsQ0FBQTthQUNyRTtZQUNELE9BQU8sQ0FBQyxHQUFHLENBQUMsbUJBQW1CLEVBQUUsZ0JBQWdCLENBQUMsQ0FBQTtZQUNsRCxNQUFNLGtCQUFHLENBQUMsU0FBUyxDQUNqQixJQUFJLENBQUMsUUFBUSxFQUNiLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBQSxtQ0FBZSxFQUFDLFFBQVEsQ0FBQyxDQUFDLENBQzFDLENBQUE7WUFFRCxJQUFJLENBQUMsY0FBYyxHQUFHLFFBQVEsQ0FBQTtRQUNoQyxDQUFDO0tBQUE7SUFFRCxNQUFNLENBQU8sVUFBVTs7WUFDckIsT0FBTyxDQUFDLEdBQUcsQ0FDVCwrQkFBK0IseUJBQXlCLENBQUMsUUFBUSxFQUFFLENBQ3BFLENBQUE7WUFDRCxNQUFNLGtCQUFHLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUUsRUFBRSxLQUFLLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQTtZQUM1QyxJQUFJLENBQUMsY0FBYyxHQUFHLFNBQVMsQ0FBQTtRQUNqQyxDQUFDO0tBQUE7O0FBMUZILDhEQTJGQztBQTFGUSxrQ0FBUSxHQUFXLGNBQUksQ0FBQyxJQUFJLENBQ2pDLGNBQUcsQ0FBQyxPQUFPLENBQUMsVUFBVSxDQUFDLEVBQ3ZCLGtCQUFrQixDQUNuQixDQUFBIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIi9Vc2Vycy9kYXJyYWdob3Jpb3JkYW4vRG9jdW1lbnRzL3BlcnNvbmFsLXByb2plY3RzL3NzaC10b29sLW5ldy1lbGVjdHJvbi9zcmMvZWxlY3Ryb24vYXBwU2V0dGluZ3Mvc2VydmljZXMvQXBwbGljYXRpb25TZXR0aW5nU2VydmljZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgZnNwIGZyb20gJ2ZzL3Byb21pc2VzJ1xuaW1wb3J0IGZzIGZyb20gJ2ZzJ1xuaW1wb3J0IHBhdGggZnJvbSAncGF0aCdcbmltcG9ydCBvcyBmcm9tICdvcydcbmltcG9ydCB7IGFwcCB9IGZyb20gJ2VsZWN0cm9uJ1xuaW1wb3J0IHsgaW5zdGFuY2VUb1BsYWluLCBwbGFpblRvSW5zdGFuY2UgfSBmcm9tICdjbGFzcy10cmFuc2Zvcm1lcidcbmltcG9ydCB7IEFwcGxpY2F0aW9uU2V0dGluZ3MgfSBmcm9tICcuLi9tb2RlbHMvQXBwbGljYXRpb25TZXR0aW5ncydcbmltcG9ydCB7IERlZmF1bHRTZXR0aW5nc01hYyB9IGZyb20gJy4uL21vZGVscy9EZWZhdWx0U2V0dGluZ3NNYWMnXG5pbXBvcnQgeyBEZWZhdWx0U2V0dGluZ3NMaW51eCB9IGZyb20gJy4uL21vZGVscy9EZWZhdWx0U2V0dGluZ3NMaW51eCdcbmltcG9ydCB7IERlZmF1bHRTZXR0aW5nc1dpbmRvd3MgfSBmcm9tICcuLi9tb2RlbHMvRGVmYXVsdFNldHRpbmdzV2luZG93cydcbmltcG9ydCB7IHZhbGlkYXRlIH0gZnJvbSAnY2xhc3MtdmFsaWRhdG9yJ1xuXG5leHBvcnQgY2xhc3MgQXBwbGljYXRpb25TZXR0aW5nU2VydmljZSB7XG4gIHN0YXRpYyBmaWxlUGF0aDogc3RyaW5nID0gcGF0aC5qb2luKFxuICAgIGFwcC5nZXRQYXRoKCd1c2VyRGF0YScpLFxuICAgICdhcHBTZXR0aW5ncy5qc29uJ1xuICApXG5cbiAgcHJpdmF0ZSBzdGF0aWMgbG9hZGVkU2V0dGluZ3M6IEFwcGxpY2F0aW9uU2V0dGluZ3MgfCB1bmRlZmluZWRcblxuICBzdGF0aWMgYXN5bmMgZ2V0U2V0dGluZ3MoKTogUHJvbWlzZTxBcHBsaWNhdGlvblNldHRpbmdzPiB7XG4gICAgaWYgKHRoaXMubG9hZGVkU2V0dGluZ3MgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5sb2FkZWRTZXR0aW5ncyA9IGF3YWl0IHRoaXMubG9hZEZpbGUodGhpcy5maWxlUGF0aClcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5sb2FkZWRTZXR0aW5nc1xuICB9XG5cbiAgc3RhdGljIGFzeW5jIGxvYWRGaWxlKHBhdGg6IHN0cmluZyk6IFByb21pc2U8QXBwbGljYXRpb25TZXR0aW5ncz4ge1xuICAgIGNvbnNvbGUubG9nKFxuICAgICAgYGxvYWRpbmcgc2V0dGluZ3MgZmlsZSBwYXRoICR7QXBwbGljYXRpb25TZXR0aW5nU2VydmljZS5maWxlUGF0aH1gXG4gICAgKVxuICAgIC8vIHRyeWluZyB0byBjYXRjaCB0aGUgZXJyb3Igb24gcHJvbWlzZXMgcmVhZEZpbGUgc3RpbGwgdGhyb3dzIGZvciBzb21lIHJlYXNvblxuICAgIC8vIHNvIHVzaW5nIHRoaXMgaW5zdGVhZFxuICAgIGlmICghZnMuZXhpc3RzU3luYyhwYXRoKSkge1xuICAgICAgY29uc3Qgc2V0dGluZ3NJbnN0YW5jZSA9IHRoaXMuZ2V0RGVmYXVsdFNldHRpbmdzKClcbiAgICAgIHRoaXMuc2F2ZUZpbGUoc2V0dGluZ3NJbnN0YW5jZSlcblxuICAgICAgcmV0dXJuIHNldHRpbmdzSW5zdGFuY2VcbiAgICB9XG5cbiAgICBjb25zdCBmaWxlVXRmOCA9IGF3YWl0IGZzcC5yZWFkRmlsZShwYXRoLCB7IGVuY29kaW5nOiAndXRmLTgnIH0pXG5cbiAgICBjb25zdCBzZXR0aW5nc0luc3RhbmNlID0gcGxhaW5Ub0luc3RhbmNlKFxuICAgICAgQXBwbGljYXRpb25TZXR0aW5ncyxcbiAgICAgIEpTT04ucGFyc2UoZmlsZVV0ZjgpXG4gICAgKVxuICAgIHJldHVybiBzZXR0aW5nc0luc3RhbmNlXG4gIH1cblxuICBzdGF0aWMgZ2V0RGVmYXVsdFNldHRpbmdzKCk6XG4gICAgfCBEZWZhdWx0U2V0dGluZ3NMaW51eFxuICAgIHwgRGVmYXVsdFNldHRpbmdzTWFjXG4gICAgfCBEZWZhdWx0U2V0dGluZ3NXaW5kb3dzIHtcbiAgICBjb25zdCBkZWZhdWx0U2V0dGluZ3MgPSBbXG4gICAgICBuZXcgRGVmYXVsdFNldHRpbmdzTWFjKCksXG4gICAgICBuZXcgRGVmYXVsdFNldHRpbmdzV2luZG93cygpLFxuICAgICAgbmV3IERlZmF1bHRTZXR0aW5nc0xpbnV4KCksXG4gICAgXVxuXG4gICAgY29uc3QgZGVmYXVsdFNldHRpbmdzSW5zdGFuY2UgPSBkZWZhdWx0U2V0dGluZ3MuZmluZChcbiAgICAgIHggPT4geC5wbGF0Zm9ybU1hdGNoZXIgPT09IG9zLnBsYXRmb3JtKClcbiAgICApXG4gICAgaWYgKGRlZmF1bHRTZXR0aW5nc0luc3RhbmNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJDb3VsZG4ndCBmaW5kIGFwcGxpY2F0aW9uIGNvbmZpZ3VyYXRpb24gdG8gcnVuIG9uIGN1cnJlbnQgcGxhdGZvcm0uIE9ubHkgbWFjLCB3aW5kb3dzIGFuZCBsaW51eCBzdXBwb3J0ZWQuXCJcbiAgICAgIClcbiAgICB9XG5cbiAgICByZXR1cm4gZGVmYXVsdFNldHRpbmdzSW5zdGFuY2VcbiAgfVxuXG4gIHN0YXRpYyBhc3luYyBzYXZlRmlsZShzZXR0aW5nczogQXBwbGljYXRpb25TZXR0aW5ncyk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnNvbGUubG9nKFxuICAgICAgYHNhdmluZyBzZXR0aW5ncyBmaWxlIHBhdGggJHtBcHBsaWNhdGlvblNldHRpbmdTZXJ2aWNlLmZpbGVQYXRofWAsXG4gICAgICBzZXR0aW5nc1xuICAgIClcblxuICAgIC8vIHdvdWxkIHByb2JhYmx5IHdhbnQgdG8gdmFsaWRhdGUgdGhlIHNldHRpbmdzIGhlcmVcbiAgICAvL3ZhbGlkYXRlT3JSZWplY3Qoc2V0dGluZ3MpXG4gICAgY29uc3QgdmFsaWRhdGlvbkVycm9ycyA9IGF3YWl0IHZhbGlkYXRlKFxuICAgICAgcGxhaW5Ub0luc3RhbmNlKEFwcGxpY2F0aW9uU2V0dGluZ3MsIHNldHRpbmdzKVxuICAgIClcbiAgICBpZiAodmFsaWRhdGlvbkVycm9ycyAmJiB2YWxpZGF0aW9uRXJyb3JzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IGVycm9ycyA9IHZhbGlkYXRpb25FcnJvcnMubWFwKHYgPT4gdi50b1N0cmluZygpKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgc2V0dGluZ3MgYXJlIGludmFsaWQuICR7JycuY29uY2F0KC4uLmVycm9ycyl9YClcbiAgICB9XG4gICAgY29uc29sZS5sb2coJ3ZhbGlkYXRpb24gZXJyb3JzJywgdmFsaWRhdGlvbkVycm9ycylcbiAgICBhd2FpdCBmc3Aud3JpdGVGaWxlKFxuICAgICAgdGhpcy5maWxlUGF0aCxcbiAgICAgIEpTT04uc3RyaW5naWZ5KGluc3RhbmNlVG9QbGFpbihzZXR0aW5ncykpXG4gICAgKVxuXG4gICAgdGhpcy5sb2FkZWRTZXR0aW5ncyA9IHNldHRpbmdzXG4gIH1cblxuICBzdGF0aWMgYXN5bmMgZGVsZXRlRmlsZSgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zb2xlLmxvZyhcbiAgICAgIGBkZWxldGluZyBzZXR0aW5ncyBmaWxlIHBhdGggJHtBcHBsaWNhdGlvblNldHRpbmdTZXJ2aWNlLmZpbGVQYXRofWBcbiAgICApXG4gICAgYXdhaXQgZnNwLnJtKHRoaXMuZmlsZVBhdGgsIHsgZm9yY2U6IHRydWUgfSlcbiAgICB0aGlzLmxvYWRlZFNldHRpbmdzID0gdW5kZWZpbmVkXG4gIH1cbn1cbiJdLCJ2ZXJzaW9uIjozfQ==
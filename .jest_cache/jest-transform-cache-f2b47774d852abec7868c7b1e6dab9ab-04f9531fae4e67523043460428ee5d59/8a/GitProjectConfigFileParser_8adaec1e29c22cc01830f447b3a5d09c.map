{"file":"/Users/darraghoriordan/Documents/personal-projects/ssh-tool-new-electron/src/electron/gitConfigurations/services/GitProjectConfigFileParser.ts","mappings":"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","names":[],"sources":["/Users/darraghoriordan/Documents/personal-projects/ssh-tool-new-electron/src/electron/gitConfigurations/services/GitProjectConfigFileParser.ts"],"sourcesContent":["import { GitUser } from '../../services/gitConfigSystemScanner/models/GitUser'\nimport { GitRemote } from '../../services/gitConfigSystemScanner/models/GitRemote'\nimport { GitConfigInfo } from '../../services/gitConfigSystemScanner/models/GitConfigInfo'\nimport { GitProtocolTypeEnum } from '../../services/gitConfigSystemScanner/models/GitProtocolTypeEnum'\nimport ini from 'ini'\nimport gitUrlParser from 'git-url-parse'\nimport { SshConfigFileLoader } from '../../services/sshConfigFile/SshConfigFileLoader'\nimport { AvailableHost } from '../../services/sshConfigFile/SshConfigFileParser'\n\nexport class GitProjectConfigFileParser {\n  static parseGitUser(rawFile: string): GitUser {\n    const parsedGlobal = ini.parse(rawFile)\n    return {\n      name: parsedGlobal.user?.name,\n      email: parsedGlobal.user?.email,\n    }\n  }\n\n  static async parseGitProjectConfig(\n    rawFile: string,\n    filePath: string\n  ): Promise<GitConfigInfo> {\n    const parsedIniFile = ini.parse(rawFile)\n    const namedSshConnections = await SshConfigFileLoader.load()\n\n    const remotesKeys = GitProjectConfigFileParser.filteredKeys(\n      parsedIniFile,\n      /^remote /\n    )\n\n    const result: GitConfigInfo = {\n      path: filePath,\n      potentialOrigins: [],\n      id: Buffer.from(filePath).toString('base64'),\n      remotes: remotesKeys.map(remoteNameKey => {\n        const rawUrl = parsedIniFile[remoteNameKey].url\n        const parsedUrl = gitUrlParser(rawUrl)\n        const urlType = this.parseUrlType(parsedUrl.protocol)\n        const remoteName = remoteNameKey\n          // eslint-disable-next-line no-useless-escape\n          .replace(/remote \"/, '')\n          .trim()\n          // eslint-disable-next-line no-useless-escape\n          .replace(/\"/, '')\n        const remote = new GitRemote()\n\n        remote.url = rawUrl\n        remote.owner = parsedUrl.owner\n        remote.pathname = parsedUrl.pathname\n        remote.protocol = parsedUrl.protocol\n        remote.source = parsedUrl.source\n        remote.port = parsedUrl.port || undefined\n        remote.user = parsedUrl.user\n        remote.repoName = parsedUrl.name\n        remote.remoteName = remoteName\n        remote.type = urlType\n        return remote\n      }),\n      user: {\n        email: parsedIniFile.user?.email,\n        name: parsedIniFile.user?.name,\n      },\n    }\n    result.originRepositoryFileName = this.extractOriginGitRepoName(result)\n    try {\n      const possibleRemotes = this.findPotentialRemoteOrigins(\n        result,\n        namedSshConnections\n      )\n      result.potentialOrigins = possibleRemotes\n    } catch (error) {\n      console.warn(\"Couldn't find a remote\", result.path)\n    }\n\n    return result\n  }\n\n  static findPotentialRemoteOrigins(\n    gitConfigInfo: GitConfigInfo,\n    listOfNamedSshConnections: AvailableHost[]\n  ): GitRemote[] {\n    // grab the single origin\n    console.info(\n      `Mapping ${listOfNamedSshConnections.length} named connections`\n    )\n    const originRemote = gitConfigInfo.remotes.find(x =>\n      x.remoteName.includes('origin')\n    )\n    // we can't change the origin if there isnt one already set\n    // but then maybe the customer will want to set one using the app?\n    // edit, no because you cant set origin with knowing base url, unless\n    // we offer a list of all potential ssh connections\n    if (!originRemote) {\n      return []\n    }\n\n    // for each config create ssh connections for each ssh certificate\n    // if ssh then for each connection add a potential http connection\n    // if ssh remove the existing named connection if in use\n    // if http then remove the potential http connection\n    // this needs a git remote connection\n    const mappedSshHostsToGitRemotes = listOfNamedSshConnections.map(x => {\n      return {\n        url: `${x.user}@${x.alias}:${originRemote.pathname.substring(1)}`, // this will have to change based on the contents of this object\n        owner: originRemote.owner,\n        pathname: originRemote.pathname,\n        protocol: 'ssh',\n        source: originRemote.source, // unsure if this changes? might like the root url? need docs\n        port: undefined,\n        user: x.user,\n        repoName: originRemote.repoName,\n        remoteName: originRemote.remoteName,\n        type: GitProtocolTypeEnum.SSH,\n      } as GitRemote\n    })\n\n    return mappedSshHostsToGitRemotes\n  }\n\n  static extractOriginGitRepoName(gitConfigInfo: GitConfigInfo): string {\n    const unknownRepoTitle = 'Unknown Remote Origin'\n    const originRemote = gitConfigInfo.remotes.find(x =>\n      x.remoteName.includes('origin')\n    )\n\n    if (originRemote === undefined) {\n      return unknownRepoTitle\n    }\n    return originRemote.repoName || unknownRepoTitle\n  }\n\n  static parseUrlType(protocol: string): GitProtocolTypeEnum {\n    switch (protocol) {\n      case 'ssh':\n        return GitProtocolTypeEnum.SSH\n      case 'http':\n      case 'https':\n        return GitProtocolTypeEnum.HTTP\n      default:\n        return GitProtocolTypeEnum.UNKNOWN\n    }\n  }\n\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  static filteredKeys = (obj: Object, filter: RegExp) => {\n    const keys = []\n    for (const key in obj)\n      if (Object.prototype.hasOwnProperty.call(obj, key) && filter.test(key)) {\n        keys.push(key)\n      }\n    return keys\n  }\n}\n"],"version":3}
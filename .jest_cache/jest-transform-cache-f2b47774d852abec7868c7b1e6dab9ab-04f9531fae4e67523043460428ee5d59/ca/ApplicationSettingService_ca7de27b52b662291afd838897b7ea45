2383ebd030c4aa4891d42c44bb51531b
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ApplicationSettingService = void 0;
const promises_1 = __importDefault(require("fs/promises"));
const fs_1 = __importDefault(require("fs"));
const os_1 = __importDefault(require("os"));
const class_transformer_1 = require("class-transformer");
const ApplicationSettings_1 = require("../models/ApplicationSettings");
const DefaultSettingsMac_1 = require("../models/DefaultSettingsMac");
const DefaultSettingsLinux_1 = require("../models/DefaultSettingsLinux");
const DefaultSettingsWindows_1 = require("../models/DefaultSettingsWindows");
const class_validator_1 = require("class-validator");
class ApplicationSettingService {
    static init({ settingsFilePath }) {
        this.filePath = settingsFilePath;
    }
    static getSettings() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.loadedSettings === undefined) {
                this.loadedSettings = yield this.loadFile(this.filePath);
            }
            return this.loadedSettings;
        });
    }
    static loadFile(path) {
        return __awaiter(this, void 0, void 0, function* () {
            console.log(`loading settings file path ${ApplicationSettingService.filePath}`);
            // trying to catch the error on promises readFile still throws for some reason
            // so using this instead
            if (!fs_1.default.existsSync(path)) {
                const settingsInstance = this.getDefaultSettings();
                this.saveFile(settingsInstance);
                return settingsInstance;
            }
            const fileUtf8 = yield promises_1.default.readFile(path, { encoding: 'utf-8' });
            const settingsInstance = (0, class_transformer_1.plainToInstance)(ApplicationSettings_1.ApplicationSettings, JSON.parse(fileUtf8));
            return settingsInstance;
        });
    }
    static getDefaultSettings() {
        const defaultSettings = [
            new DefaultSettingsMac_1.DefaultSettingsMac(),
            new DefaultSettingsWindows_1.DefaultSettingsWindows(),
            new DefaultSettingsLinux_1.DefaultSettingsLinux(),
        ];
        const defaultSettingsInstance = defaultSettings.find(x => x.platformMatcher === os_1.default.platform());
        if (defaultSettingsInstance === undefined) {
            throw new Error("Couldn't find application configuration to run on current platform. Only mac, windows and linux supported.");
        }
        return defaultSettingsInstance;
    }
    static saveFile(settings) {
        return __awaiter(this, void 0, void 0, function* () {
            console.log(`saving settings file path ${ApplicationSettingService.filePath}`, settings);
            // would probably want to validate the settings here
            //validateOrReject(settings)
            const validationErrors = yield (0, class_validator_1.validate)((0, class_transformer_1.plainToInstance)(ApplicationSettings_1.ApplicationSettings, settings));
            if (validationErrors && validationErrors.length > 0) {
                const errors = validationErrors.map(v => v.toString());
                throw new Error(`The settings are invalid. ${''.concat(...errors)}`);
            }
            console.log('validation errors', validationErrors);
            yield promises_1.default.writeFile(this.filePath, JSON.stringify((0, class_transformer_1.instanceToPlain)(settings)));
            this.loadedSettings = settings;
        });
    }
    static deleteFile() {
        return __awaiter(this, void 0, void 0, function* () {
            console.log(`deleting settings file path ${ApplicationSettingService.filePath}`);
            yield promises_1.default.rm(this.filePath, { force: true });
            this.loadedSettings = undefined;
        });
    }
}
exports.ApplicationSettingService = ApplicationSettingService;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL2RhcnJhZ2hvcmlvcmRhbi9Eb2N1bWVudHMvcGVyc29uYWwtcHJvamVjdHMvc3NoLXRvb2wtbmV3LWVsZWN0cm9uL3NyYy9lbGVjdHJvbi9hcHBTZXR0aW5ncy9zZXJ2aWNlcy9BcHBsaWNhdGlvblNldHRpbmdTZXJ2aWNlLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFBLDJEQUE2QjtBQUM3Qiw0Q0FBbUI7QUFDbkIsNENBQW1CO0FBQ25CLHlEQUFvRTtBQUNwRSx1RUFBbUU7QUFDbkUscUVBQWlFO0FBQ2pFLHlFQUFxRTtBQUNyRSw2RUFBeUU7QUFDekUscURBQTBDO0FBRTFDLE1BQWEseUJBQXlCO0lBS3BDLE1BQU0sQ0FBQyxJQUFJLENBQUMsRUFBRSxnQkFBZ0IsRUFBZ0M7UUFDNUQsSUFBSSxDQUFDLFFBQVEsR0FBRyxnQkFBZ0IsQ0FBQTtJQUNsQyxDQUFDO0lBRUQsTUFBTSxDQUFPLFdBQVc7O1lBQ3RCLElBQUksSUFBSSxDQUFDLGNBQWMsS0FBSyxTQUFTLEVBQUU7Z0JBQ3JDLElBQUksQ0FBQyxjQUFjLEdBQUcsTUFBTSxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQTthQUN6RDtZQUVELE9BQU8sSUFBSSxDQUFDLGNBQWMsQ0FBQTtRQUM1QixDQUFDO0tBQUE7SUFFRCxNQUFNLENBQU8sUUFBUSxDQUFDLElBQVk7O1lBQ2hDLE9BQU8sQ0FBQyxHQUFHLENBQ1QsOEJBQThCLHlCQUF5QixDQUFDLFFBQVEsRUFBRSxDQUNuRSxDQUFBO1lBQ0QsOEVBQThFO1lBQzlFLHdCQUF3QjtZQUN4QixJQUFJLENBQUMsWUFBRSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsRUFBRTtnQkFDeEIsTUFBTSxnQkFBZ0IsR0FBRyxJQUFJLENBQUMsa0JBQWtCLEVBQUUsQ0FBQTtnQkFDbEQsSUFBSSxDQUFDLFFBQVEsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFBO2dCQUUvQixPQUFPLGdCQUFnQixDQUFBO2FBQ3hCO1lBRUQsTUFBTSxRQUFRLEdBQUcsTUFBTSxrQkFBRyxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUUsRUFBRSxRQUFRLEVBQUUsT0FBTyxFQUFFLENBQUMsQ0FBQTtZQUVoRSxNQUFNLGdCQUFnQixHQUFHLElBQUEsbUNBQWUsRUFDdEMseUNBQW1CLEVBQ25CLElBQUksQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLENBQ3JCLENBQUE7WUFDRCxPQUFPLGdCQUFnQixDQUFBO1FBQ3pCLENBQUM7S0FBQTtJQUVELE1BQU0sQ0FBQyxrQkFBa0I7UUFJdkIsTUFBTSxlQUFlLEdBQUc7WUFDdEIsSUFBSSx1Q0FBa0IsRUFBRTtZQUN4QixJQUFJLCtDQUFzQixFQUFFO1lBQzVCLElBQUksMkNBQW9CLEVBQUU7U0FDM0IsQ0FBQTtRQUVELE1BQU0sdUJBQXVCLEdBQUcsZUFBZSxDQUFDLElBQUksQ0FDbEQsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsZUFBZSxLQUFLLFlBQUUsQ0FBQyxRQUFRLEVBQUUsQ0FDekMsQ0FBQTtRQUNELElBQUksdUJBQXVCLEtBQUssU0FBUyxFQUFFO1lBQ3pDLE1BQU0sSUFBSSxLQUFLLENBQ2IsNEdBQTRHLENBQzdHLENBQUE7U0FDRjtRQUVELE9BQU8sdUJBQXVCLENBQUE7SUFDaEMsQ0FBQztJQUVELE1BQU0sQ0FBTyxRQUFRLENBQUMsUUFBNkI7O1lBQ2pELE9BQU8sQ0FBQyxHQUFHLENBQ1QsNkJBQTZCLHlCQUF5QixDQUFDLFFBQVEsRUFBRSxFQUNqRSxRQUFRLENBQ1QsQ0FBQTtZQUVELG9EQUFvRDtZQUNwRCw0QkFBNEI7WUFDNUIsTUFBTSxnQkFBZ0IsR0FBRyxNQUFNLElBQUEsMEJBQVEsRUFDckMsSUFBQSxtQ0FBZSxFQUFDLHlDQUFtQixFQUFFLFFBQVEsQ0FBQyxDQUMvQyxDQUFBO1lBQ0QsSUFBSSxnQkFBZ0IsSUFBSSxnQkFBZ0IsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFO2dCQUNuRCxNQUFNLE1BQU0sR0FBRyxnQkFBZ0IsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsUUFBUSxFQUFFLENBQUMsQ0FBQTtnQkFDdEQsTUFBTSxJQUFJLEtBQUssQ0FBQyw2QkFBNkIsRUFBRSxDQUFDLE1BQU0sQ0FBQyxHQUFHLE1BQU0sQ0FBQyxFQUFFLENBQUMsQ0FBQTthQUNyRTtZQUNELE9BQU8sQ0FBQyxHQUFHLENBQUMsbUJBQW1CLEVBQUUsZ0JBQWdCLENBQUMsQ0FBQTtZQUNsRCxNQUFNLGtCQUFHLENBQUMsU0FBUyxDQUNqQixJQUFJLENBQUMsUUFBUSxFQUNiLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBQSxtQ0FBZSxFQUFDLFFBQVEsQ0FBQyxDQUFDLENBQzFDLENBQUE7WUFFRCxJQUFJLENBQUMsY0FBYyxHQUFHLFFBQVEsQ0FBQTtRQUNoQyxDQUFDO0tBQUE7SUFFRCxNQUFNLENBQU8sVUFBVTs7WUFDckIsT0FBTyxDQUFDLEdBQUcsQ0FDVCwrQkFBK0IseUJBQXlCLENBQUMsUUFBUSxFQUFFLENBQ3BFLENBQUE7WUFDRCxNQUFNLGtCQUFHLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUUsRUFBRSxLQUFLLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQTtZQUM1QyxJQUFJLENBQUMsY0FBYyxHQUFHLFNBQVMsQ0FBQTtRQUNqQyxDQUFDO0tBQUE7Q0FDRjtBQTVGRCw4REE0RkMiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiL1VzZXJzL2RhcnJhZ2hvcmlvcmRhbi9Eb2N1bWVudHMvcGVyc29uYWwtcHJvamVjdHMvc3NoLXRvb2wtbmV3LWVsZWN0cm9uL3NyYy9lbGVjdHJvbi9hcHBTZXR0aW5ncy9zZXJ2aWNlcy9BcHBsaWNhdGlvblNldHRpbmdTZXJ2aWNlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBmc3AgZnJvbSAnZnMvcHJvbWlzZXMnXG5pbXBvcnQgZnMgZnJvbSAnZnMnXG5pbXBvcnQgb3MgZnJvbSAnb3MnXG5pbXBvcnQgeyBpbnN0YW5jZVRvUGxhaW4sIHBsYWluVG9JbnN0YW5jZSB9IGZyb20gJ2NsYXNzLXRyYW5zZm9ybWVyJ1xuaW1wb3J0IHsgQXBwbGljYXRpb25TZXR0aW5ncyB9IGZyb20gJy4uL21vZGVscy9BcHBsaWNhdGlvblNldHRpbmdzJ1xuaW1wb3J0IHsgRGVmYXVsdFNldHRpbmdzTWFjIH0gZnJvbSAnLi4vbW9kZWxzL0RlZmF1bHRTZXR0aW5nc01hYydcbmltcG9ydCB7IERlZmF1bHRTZXR0aW5nc0xpbnV4IH0gZnJvbSAnLi4vbW9kZWxzL0RlZmF1bHRTZXR0aW5nc0xpbnV4J1xuaW1wb3J0IHsgRGVmYXVsdFNldHRpbmdzV2luZG93cyB9IGZyb20gJy4uL21vZGVscy9EZWZhdWx0U2V0dGluZ3NXaW5kb3dzJ1xuaW1wb3J0IHsgdmFsaWRhdGUgfSBmcm9tICdjbGFzcy12YWxpZGF0b3InXG5cbmV4cG9ydCBjbGFzcyBBcHBsaWNhdGlvblNldHRpbmdTZXJ2aWNlIHtcbiAgc3RhdGljIGZpbGVQYXRoOiBzdHJpbmdcblxuICBwcml2YXRlIHN0YXRpYyBsb2FkZWRTZXR0aW5nczogQXBwbGljYXRpb25TZXR0aW5ncyB8IHVuZGVmaW5lZFxuXG4gIHN0YXRpYyBpbml0KHsgc2V0dGluZ3NGaWxlUGF0aCB9OiB7IHNldHRpbmdzRmlsZVBhdGg6IHN0cmluZyB9KTogdm9pZCB7XG4gICAgdGhpcy5maWxlUGF0aCA9IHNldHRpbmdzRmlsZVBhdGhcbiAgfVxuXG4gIHN0YXRpYyBhc3luYyBnZXRTZXR0aW5ncygpOiBQcm9taXNlPEFwcGxpY2F0aW9uU2V0dGluZ3M+IHtcbiAgICBpZiAodGhpcy5sb2FkZWRTZXR0aW5ncyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLmxvYWRlZFNldHRpbmdzID0gYXdhaXQgdGhpcy5sb2FkRmlsZSh0aGlzLmZpbGVQYXRoKVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmxvYWRlZFNldHRpbmdzXG4gIH1cblxuICBzdGF0aWMgYXN5bmMgbG9hZEZpbGUocGF0aDogc3RyaW5nKTogUHJvbWlzZTxBcHBsaWNhdGlvblNldHRpbmdzPiB7XG4gICAgY29uc29sZS5sb2coXG4gICAgICBgbG9hZGluZyBzZXR0aW5ncyBmaWxlIHBhdGggJHtBcHBsaWNhdGlvblNldHRpbmdTZXJ2aWNlLmZpbGVQYXRofWBcbiAgICApXG4gICAgLy8gdHJ5aW5nIHRvIGNhdGNoIHRoZSBlcnJvciBvbiBwcm9taXNlcyByZWFkRmlsZSBzdGlsbCB0aHJvd3MgZm9yIHNvbWUgcmVhc29uXG4gICAgLy8gc28gdXNpbmcgdGhpcyBpbnN0ZWFkXG4gICAgaWYgKCFmcy5leGlzdHNTeW5jKHBhdGgpKSB7XG4gICAgICBjb25zdCBzZXR0aW5nc0luc3RhbmNlID0gdGhpcy5nZXREZWZhdWx0U2V0dGluZ3MoKVxuICAgICAgdGhpcy5zYXZlRmlsZShzZXR0aW5nc0luc3RhbmNlKVxuXG4gICAgICByZXR1cm4gc2V0dGluZ3NJbnN0YW5jZVxuICAgIH1cblxuICAgIGNvbnN0IGZpbGVVdGY4ID0gYXdhaXQgZnNwLnJlYWRGaWxlKHBhdGgsIHsgZW5jb2Rpbmc6ICd1dGYtOCcgfSlcblxuICAgIGNvbnN0IHNldHRpbmdzSW5zdGFuY2UgPSBwbGFpblRvSW5zdGFuY2UoXG4gICAgICBBcHBsaWNhdGlvblNldHRpbmdzLFxuICAgICAgSlNPTi5wYXJzZShmaWxlVXRmOClcbiAgICApXG4gICAgcmV0dXJuIHNldHRpbmdzSW5zdGFuY2VcbiAgfVxuXG4gIHN0YXRpYyBnZXREZWZhdWx0U2V0dGluZ3MoKTpcbiAgICB8IERlZmF1bHRTZXR0aW5nc0xpbnV4XG4gICAgfCBEZWZhdWx0U2V0dGluZ3NNYWNcbiAgICB8IERlZmF1bHRTZXR0aW5nc1dpbmRvd3Mge1xuICAgIGNvbnN0IGRlZmF1bHRTZXR0aW5ncyA9IFtcbiAgICAgIG5ldyBEZWZhdWx0U2V0dGluZ3NNYWMoKSxcbiAgICAgIG5ldyBEZWZhdWx0U2V0dGluZ3NXaW5kb3dzKCksXG4gICAgICBuZXcgRGVmYXVsdFNldHRpbmdzTGludXgoKSxcbiAgICBdXG5cbiAgICBjb25zdCBkZWZhdWx0U2V0dGluZ3NJbnN0YW5jZSA9IGRlZmF1bHRTZXR0aW5ncy5maW5kKFxuICAgICAgeCA9PiB4LnBsYXRmb3JtTWF0Y2hlciA9PT0gb3MucGxhdGZvcm0oKVxuICAgIClcbiAgICBpZiAoZGVmYXVsdFNldHRpbmdzSW5zdGFuY2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIkNvdWxkbid0IGZpbmQgYXBwbGljYXRpb24gY29uZmlndXJhdGlvbiB0byBydW4gb24gY3VycmVudCBwbGF0Zm9ybS4gT25seSBtYWMsIHdpbmRvd3MgYW5kIGxpbnV4IHN1cHBvcnRlZC5cIlxuICAgICAgKVxuICAgIH1cblxuICAgIHJldHVybiBkZWZhdWx0U2V0dGluZ3NJbnN0YW5jZVxuICB9XG5cbiAgc3RhdGljIGFzeW5jIHNhdmVGaWxlKHNldHRpbmdzOiBBcHBsaWNhdGlvblNldHRpbmdzKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc29sZS5sb2coXG4gICAgICBgc2F2aW5nIHNldHRpbmdzIGZpbGUgcGF0aCAke0FwcGxpY2F0aW9uU2V0dGluZ1NlcnZpY2UuZmlsZVBhdGh9YCxcbiAgICAgIHNldHRpbmdzXG4gICAgKVxuXG4gICAgLy8gd291bGQgcHJvYmFibHkgd2FudCB0byB2YWxpZGF0ZSB0aGUgc2V0dGluZ3MgaGVyZVxuICAgIC8vdmFsaWRhdGVPclJlamVjdChzZXR0aW5ncylcbiAgICBjb25zdCB2YWxpZGF0aW9uRXJyb3JzID0gYXdhaXQgdmFsaWRhdGUoXG4gICAgICBwbGFpblRvSW5zdGFuY2UoQXBwbGljYXRpb25TZXR0aW5ncywgc2V0dGluZ3MpXG4gICAgKVxuICAgIGlmICh2YWxpZGF0aW9uRXJyb3JzICYmIHZhbGlkYXRpb25FcnJvcnMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgZXJyb3JzID0gdmFsaWRhdGlvbkVycm9ycy5tYXAodiA9PiB2LnRvU3RyaW5nKCkpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBzZXR0aW5ncyBhcmUgaW52YWxpZC4gJHsnJy5jb25jYXQoLi4uZXJyb3JzKX1gKVxuICAgIH1cbiAgICBjb25zb2xlLmxvZygndmFsaWRhdGlvbiBlcnJvcnMnLCB2YWxpZGF0aW9uRXJyb3JzKVxuICAgIGF3YWl0IGZzcC53cml0ZUZpbGUoXG4gICAgICB0aGlzLmZpbGVQYXRoLFxuICAgICAgSlNPTi5zdHJpbmdpZnkoaW5zdGFuY2VUb1BsYWluKHNldHRpbmdzKSlcbiAgICApXG5cbiAgICB0aGlzLmxvYWRlZFNldHRpbmdzID0gc2V0dGluZ3NcbiAgfVxuXG4gIHN0YXRpYyBhc3luYyBkZWxldGVGaWxlKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnNvbGUubG9nKFxuICAgICAgYGRlbGV0aW5nIHNldHRpbmdzIGZpbGUgcGF0aCAke0FwcGxpY2F0aW9uU2V0dGluZ1NlcnZpY2UuZmlsZVBhdGh9YFxuICAgIClcbiAgICBhd2FpdCBmc3Aucm0odGhpcy5maWxlUGF0aCwgeyBmb3JjZTogdHJ1ZSB9KVxuICAgIHRoaXMubG9hZGVkU2V0dGluZ3MgPSB1bmRlZmluZWRcbiAgfVxufVxuIl0sInZlcnNpb24iOjN9